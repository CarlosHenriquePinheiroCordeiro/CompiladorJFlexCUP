package compilador;

import java.io.*;
import java_cup.runtime.*;
import compilador.Lexico;
import objetos.*;
import java.util.ArrayList;

parser code
{:
    private TabelaSimbolos tb = new TabelaSimbolos();
    
    public void syntax_error(Symbol s){
        String strErro = "Erro de sintaxe. Linha: " + (s.right + 1) +
            " Coluna: " + s.left + ". Texto: \"" + s.value + "\"" + " \n Token Encontrado: " + sym.terminalNames[s.sym] + " state " + s.parse_state;
        
        report_error(strErro, null); 
    }
    
    public TabelaSimbolos getTb() {
    	return this.tb;
	}
:};

terminal PROGRAM      , IF     , TRUE   , FLOAT  , FALSE  , INT      , 
         STRING       , BOOL   , VOID   , PUBLIC , PRIVATE, PROTECTED, 
         RETURN       , AP     , FP     , AC     , FC     , ASP      , 
         PONTO_VIRGULA, PONTO  , VIRGULA, ARRAY  , SOMA   , SUB      , 
         MULT         , DIV    , ATT    , IGUAL  , DIF    , MAIORQ   , 
         MENORQ       , MAIORI , MENORI , NAO    , E      , OU       , 
         ID           , CONST  , FLUT   , ERRO   , TIPO   , CADEIA   , WS;

non terminal PROGRAMA_ESCOPO;
non terminal Programa PROGRAMA;
non terminal ArrayList<Var> LISTA_VAR;
non terminal Var VAR;
non terminal IDENTIFICADOR;
non terminal Atribuicao ATRIBUICAO;
non terminal TERMO;
non terminal PARAMETRO;
non terminal OPERADOR_ARIT;
non terminal OPERADOR_BOOL;
non terminal Expressao EXPRESSAO;
non terminal Escopo SCOPE;
non terminal Funcao FUNCAO;
non terminal CALL_FUNC;
non terminal ESTRUTURA;
non terminal SELECAO;
non terminal ABRE_BLOCO;
non terminal Bloco BLOCO;
non terminal TIPO_RETORNO;
non terminal RETORNO;

PROGRAMA ::= PROGRAMA_ESCOPO ID:id AP LISTA_VAR:listaVar FP AC BLOCO:bloco FC
			{: 	RESULT = new Programa(id, listaVar, bloco); :};

PROGRAMA_ESCOPO ::= PROGRAM {: getTb().novoEscopo(); :};

LISTA_VAR ::= LISTA_VAR:listaVar VIRGULA VAR:var {: listaVar.add(var); RESULT = listaVar; :}
			| VAR:v {: RESULT = new ArrayList<Var>(); RESULT.add(v); :}
			| 
			;

VAR ::= TIPO:tipo ID:id 
	{: RESULT = new Var(tipo, id); getTb().novoSimbolo(id, tipo); :};

IDENTIFICADOR ::= ID:id {: getTb().verificaUsaSimbolo(id); :};

TERMO ::= TRUE
		| FALSE
		| IDENTIFICADOR 
		| NAO IDENTIFICADOR
		| CADEIA
		| CONST
		| FLUT;

PARAMETRO ::= TERMO 
			| TERMO VIRGULA PARAMETRO
			| ;

OPERADOR_ARIT ::= SOMA 
				| SUB 
				| MULT 
				| DIV;

OPERADOR_BOOL ::= MAIORQ 
				| MENORQ 
				| MAIORI 
				| MENORI 
				| IGUAL
				| DIF
				| E
				| OU;

EXPRESSAO ::= TERMO:termo {: RESULT = new Expressao(termo); :}
			| TERMO:termo OPERADOR_ARIT:op EXPRESSAO:exp {: RESULT = new Expressao(termo, op, exp); :}
			| TERMO:termo OPERADOR_BOOL:op EXPRESSAO:exp {: RESULT = new Expressao(termo, op, exp); :};

SCOPE ::= PUBLIC 
		| PRIVATE 
		| PROTECTED;

TIPO_RETORNO ::= TIPO
			   | VOID;

FUNCAO ::= SCOPE TIPO_RETORNO ID AP LISTA_VAR FP ABRE_BLOCO BLOCO RETORNO FC;

CALL_FUNC ::= ID AP PARAMETRO FP;

ESTRUTURA ::= SELECAO;

SELECAO ::= IF AP EXPRESSAO FP ABRE_BLOCO BLOCO FC;

ATRIBUICAO ::= VAR:var ATT:opAtt EXPRESSAO:exp {: getTb().atribuiValor(var.getId(), exp.getTermo()); //validar tipo com tipoxright e tipoxleft ou varxright varxright ;:}
		| IDENTIFICADOR:id ATT:opAtt EXPRESSAO:exp {: getTb().atribuiValor(id, exp.getTermo());:};

ABRE_BLOCO ::= AC {: getTb().novoEscopo(); :};

BLOCO ::= VAR PONTO_VIRGULA BLOCO
		| ATRIBUICAO PONTO_VIRGULA BLOCO
		| EXPRESSAO PONTO_VIRGULA BLOCO 
		| CALL_FUNC PONTO_VIRGULA BLOCO 
		| FUNCAO BLOCO
		| ESTRUTURA BLOCO
		| {: getTb().fimEscopo(); :};

RETORNO ::= RETURN EXPRESSAO PONTO_VIRGULA
		  | RETURN CALL_FUNC PONTO_VIRGULA
		  | ;